#                    volatile

### 1、介绍

volatile是一个类型修饰符（type specifier）。它是被设计用来修饰被不同线程访问和修改的变量。如果没有volatile，基本上会导致这样的结果：要么无法编写多线程程序，要么编译器失去大量优化的机会。

### 2.一般用处

一般说来，volatile用在如下的几个地方：

### **1）并行设备的硬件寄存器（如：状态寄存器）** 

**存储器映射的硬件寄存器通常也要加 voliate，因为每次对它的读写都可能有不同意义。**

例如：假设要对一个设备进行初始化，此设备的某一个寄存器为0xff800000。

> int *output = (unsigned int *)0xff800000;//定义一个IO端口；
> int init(void)
> {
> int i;
> for(i=0;i< 10;i++){
> *output = i;
> }
> }

经过编译器优化后，编译器认为前面循环半天都是废话，对最后的结果毫无影响，因为最终只是将output这个指针赋值为 9，所以编译器最后给你编译编译的代码结果相当于：

> int init(void)
> {
> *output =9;
> }

如果你对此外部设备进行初始化的过程是必须是像上面代码一样顺序的对其赋值，显然优化过程并不能达到目的。反之如果你不是对此端口反复写操作，而是反复读操作，其结果是一样的，编译器在优化后，也许你的代码对此地址的读操作只做了一次。然而从代码角度看是没有任何问题的。这时候就该使用volatile通知编译器这个变量是一个不稳定的，在遇到此变量时候不要优化。

### 2）中断服务程序中修改的供其它程序检测的变量，需要加volatile；

当变量在触发某中断程序中修改，而编译器判断主函数里面没有修改该变量，因此可能只执行一次从内存到某寄存器的读操作，而后每次只会从该寄存器中读取变量副本，使得中断程序的操作被短路。

### 3）多任务环境下各任务间共享的标志，应该加volatile；

在本次线程内, 当读取一个变量时，编译器优化时有时会先把变量读取到一个寄存器中；以后，再取变量值时，就直接从寄存器中取值；当内存变量或寄存器变量在因别的线程等而改变了值，该寄存器的值不会相应改变，从而造成应用程序读取的值和实际的变量值不一致 。

### 4）存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义；

　　假设要对一个设备进行初始化，此设备的某一个寄存器为0xff800000。for(i=0;i< 10;i++) *output = i;前面循环半天都是废话，对最后的结果毫无影响，因为最终只是将output这个指针赋值为9，省略了对该硬件IO端口反复读的操作。

**这是区分C程序员和嵌入式系统程序员的最基本的问题：**嵌入式系统程序员经常同硬件、中断、RTOS等等打交道，所有这些都要求使用volatile变量。不懂得volatile内容将会带来灾难。

### **3.volatile 问题和总结**

volatile 常见的几个**面试题**：

### 1)一个参数既可以是const还可以是volatile吗？

可以的，例如只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。

### 2) 一个指针可以是volatile 吗？

　　可以，当一个中服务子程序修改一个指向buffer的指针时。

### 4.下面的函数有什么错误？ 

> int square(volatile int*ptr)
> {
> return*ptr * *ptr;
> }

该程序的目的是用来返指针*ptr指向值的平方，但是，由于*ptr指向一个volatile型参数，编译器将产生类似下面的代码：

> int square(volatile int*ptr)
> {
> int a,b;
> a = *ptr;
> b = *ptr;
> return a * b;
> }

由于*ptr的值可能被意想不到地该变，因此a和b可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下：

> long square(volatile int*ptr)
> {
> int a;
> a = *ptr;
> return a * a;
> }

注意：频繁地使用volatile很可能会增加代码尺寸和降低性能,因此要合理的使用volatile。

### **总结：** 

**volatile 关键字是一种类型修饰符**，用它声明的类型变量表示可以被某些编译器未知的因素更改。volatile 提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会**直接从变量地址中读取数据**。如 果没有 volatile 关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象。所以**遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问**。